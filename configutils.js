// Generated by CoffeeScript 2.7.0
//#############################################################################
//region debug
var configPath, createNewConfig, cryptoNode, decryptContent, envSalt, getKey, hexXOR, localConfig, log, olog, saveConfig;

import {
  createLogFunctions
} from "thingy-debug";

({log, olog} = createLogFunctions("configutils"));

import fs from "node:fs";

import os from "node:os";

import path from "node:path";

import crypto from "node:crypto";

import * as secUtl from "secret-manager-crypto-utils";

import * as tbut from "thingy-byte-utils";

import {
  ThingyCryptoNode
} from "thingy-crypto-node";

import * as ui from "./uimodule.js";

//endregion

//#############################################################################
//region local variables
configPath = path.join(os.homedir(), ".config", "devloop", "devloop.json");

envSalt = (function() {
  var base, machineId;
  base = os.homedir() + os.hostname() + os.userInfo().username; // Linux machine-id adds extra entropy
  try {
    machineId = fs.readFileSync("/etc/machine-id", "utf8").trim();
    return machineId + base;
  } catch (error) {
    return base;
  }
})();

//#############################################################################
cryptoNode = "";

//#############################################################################
localConfig = null;

//endregion

//#############################################################################
export var readLocalConfig = async function() {
  var cfg, configString, err;
  log("readLocalConfig");
  try {
    configString = fs.readFileSync(configPath, "utf8");
    cfg = JSON.parse(configString);
    await decryptContent(cfg);
  } catch (error) {
    err = error;
    if (err.code === 'ENOENT') {
      await createNewConfig();
    } else {
      throw err;
    }
  }
  return localConfig.content;
};

//#############################################################################
export var updateLocalConfig = async function(content, validProps) {
  var lbl, updated, val;
  log("updateLocalConfig");
  validProps = new Set(validProps);
  updated = [];
  for (lbl in content) {
    val = content[lbl];
    if (validProps.has(lbl)) {
      if (localConfig.content[lbl] !== val) {
        localConfig.content[lbl] = val;
        updated.push(lbl);
      }
    }
  }
  if (updated.length > 0) {
    await saveConfig();
  }
  return updated;
};

//#############################################################################
createNewConfig = async function() {
  var confirmPw, err, keyFragment, publicKeyHex, pwd, secretKeyHex;
  log("createNewConfig");
  console.log(`No config found. Creating new config at ${configPath}`);
  try {
    // Ask if user wants password protection
    pwd = (await ui.retrieveSecret("New Password:"));
    confirmPw = (await ui.retrieveSecret("Confirm password:"));
  } catch (error) {
    err = error;
    process.exit(0); // when user cancelled exit application
  }
  if (pwd !== confirmPw) {
    console.error("Passwords don't match. Try again.");
    return createNewConfig();
  }
  // Generate random keyFragment (32 bytes = 64 hex chars)
  keyFragment = tbut.bytesToHex(crypto.randomBytes(32));
  // Derive key and setup crypto
  secretKeyHex = (await getKey(pwd, keyFragment));
  publicKeyHex = (await secUtl.createPublicKey(secretKeyHex));
  cryptoNode = new ThingyCryptoNode({secretKeyHex, publicKeyHex});
  // Initialize with empty content
  localConfig = {
    keyFragment,
    content: {}
  };
  // Save to disk
  await saveConfig();
  console.log("Config created successfully.");
};

//#############################################################################
decryptContent = async function(cfg) {
  var content, contentString, err, password, publicKeyHex, secretKeyHex;
  log("decryptContent"); // first try to decrypt without password
  try {
    secretKeyHex = (await getKey("", cfg.keyFragment));
    publicKeyHex = (await secUtl.createPublicKey(secretKeyHex));
    cryptoNode = new ThingyCryptoNode({secretKeyHex, publicKeyHex});
    contentString = (await cryptoNode.decrypt(cfg.content));
    content = JSON.parse(contentString);
    //# no exception - seems succesful :-)
    localConfig = {
      keyFragment: cfg.keyFragment,
      content: content
    };
    console.log(`Parsed config (${configPath}).`);
    return;
  } catch (error) {
    err = error;
    log(err); // loop trough password attempts
  }
  while (true) {
    try {
      try {
        password = (await ui.retrieveSecret("Password:"));
      } catch (error) {
        err = error;
        process.exit(0); // when user cancelled exit application
      }
      secretKeyHex = (await getKey(password, cfg.keyFragment));
      publicKeyHex = (await secUtl.createPublicKey(secretKeyHex));
      cryptoNode = new ThingyCryptoNode({secretKeyHex, publicKeyHex});
      contentString = (await cryptoNode.decrypt(cfg.content));
      content = JSON.parse(contentString);
      //# no exception - seems succesful :-)
      localConfig = {
        keyFragment: cfg.keyFragment,
        content: content
      };
      return;
    } catch (error) {
      err = error;
      console.error(err);
    }
  }
};

saveConfig = async function() {
  var cfg, configDir;
  log("saveConfig");
  cfg = {};
  cfg.keyFragment = localConfig.keyFragment;
  cfg.content = (await cryptoNode.encrypt(JSON.stringify(localConfig.content)));
  // Ensure directory exists
  configDir = path.dirname(configPath);
  fs.mkdirSync(configDir, {
    recursive: true
  });
  // Write config
  fs.writeFileSync(configPath, JSON.stringify(cfg, null, 2));
};

//#############################################################################
getKey = async function(password, keyFrag1) {
  var keyFrag0;
  log("getKey");
  keyFrag0 = (await secUtl.sha512Hex(envSalt + password));
  return hexXOR(keyFrag0.slice(0, 64), keyFrag1); // 32 bytes = 64 hex chars    
};

hexXOR = function(kHex, sHex) {
  var i, j, kByte, kBytes, len, rBytes, sBytes;
  if (kHex.length !== sHex.length) {
    throw new Error("Keys must have same length!");
  }
  kBytes = tbut.hexToBytes(kHex);
  sBytes = tbut.hexToBytes(sHex);
  rBytes = new Uint8Array(kBytes.length);
  for (i = j = 0, len = kBytes.length; j < len; i = ++j) {
    kByte = kBytes[i];
    rBytes[i] = kByte ^ sBytes[i];
  }
  return tbut.bytesToHex(rBytes);
};
